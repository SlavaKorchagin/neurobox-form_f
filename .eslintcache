[{"/Users/slava/Desktop/work/neurobox-form_f/src/index.js":"1","/Users/slava/Desktop/work/neurobox-form_f/src/App.js":"2","/Users/slava/Desktop/work/neurobox-form_f/src/reportWebVitals.js":"3","/Users/slava/Desktop/work/neurobox-form_f/src/form/index.jsx":"4","/Users/slava/Desktop/work/neurobox-form_f/src/functions.js":"5","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SliderField.jsx":"6","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/LinesAreasCanvasField.jsx":"7","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/ArrowAreasCanvasField.jsx":"8","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/NumberField.jsx":"9","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SelectField.jsx":"10","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/RangeField.jsx":"11","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/utils.js":"12"},{"size":478,"mtime":1612473930326,"results":"13","hashOfConfig":"14"},{"size":537,"mtime":1612473930320,"results":"15","hashOfConfig":"14"},{"size":362,"mtime":1612473930326,"results":"16","hashOfConfig":"14"},{"size":2177,"mtime":1612639415544,"results":"17","hashOfConfig":"14"},{"size":976,"mtime":1612473930326,"results":"18","hashOfConfig":"14"},{"size":5380,"mtime":1612781703986,"results":"19","hashOfConfig":"14"},{"size":18969,"mtime":1612781882774,"results":"20","hashOfConfig":"14"},{"size":22255,"mtime":1612781882768,"results":"21","hashOfConfig":"14"},{"size":2703,"mtime":1612478815473,"results":"22","hashOfConfig":"14"},{"size":1017,"mtime":1612473930323,"results":"23","hashOfConfig":"14"},{"size":8055,"mtime":1612781703989,"results":"24","hashOfConfig":"14"},{"size":2971,"mtime":1612717914407,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"11cktcs",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"28"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"28"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"28"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/Users/slava/Desktop/work/neurobox-form_f/src/index.js",[],["55","56"],"/Users/slava/Desktop/work/neurobox-form_f/src/App.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/reportWebVitals.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/form/index.jsx",[],"/Users/slava/Desktop/work/neurobox-form_f/src/functions.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SliderField.jsx",["57"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/LinesAreasCanvasField.jsx",["58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76"],"\nimport React, {Component, useEffect, useState,useRef} from 'react';\nimport {Field, useFormikContext} from \"formik\";\nimport {convexShape,hexToRgb,lineIntersect} from './utils';\nimport area from './../../assets/area.svg';\nimport areaActive from './../../assets/areaActive.svg';\nimport line from './../../assets/line.svg';\nimport lineActive from './../../assets/lineActive.svg';\nimport edit from './../../assets/edit.svg';\nimport editActive from './../../assets/editActive.svg';\nimport eraser from './../../assets/eraser.svg';\nimport eraserActive from './../../assets/eraserActive.svg';\n\nfunction LinesAreasCanvasField(props) {\n    const form = useFormikContext();\n    const { values, submitForm } = useFormikContext();\n\n    let imgReq = 'https://www.newsko.ru/media/6311833/dorogi-perm.jpg';\n\n    let ctxCanvas = useRef(null);\n    let errorMessage = useRef([]);\n    let imageTest = useRef(new Image());\n    const canvasWidth = useRef(600);\n    const canvasHeight = useRef('');\n    let loadImage = useRef(false);\n    let cursor = useRef('');\n\n    let originWidth = 0;\n    let originHeight = 0;\n    let mouse = [];\n    let colorCanvas = [];\n    let scaleImage = useRef('');\n\n    let move = false;\n    let indexMove = null;\n\n\n\n    const canvas = useRef(null);\n\n    const [data, setData] = useState({\n        arr: values.lines_and_areas && values.lines_and_areas.length > 0 ? values.lines_and_areas : []\n    });\n    const [activeIndex, setIndex] = useState('');\n\n    const [stateButton,setValueButton] = useState({\n        line: false,\n        area: false,\n        edit: false,\n        eraser: false\n    });\n\n    useEffect(()=>{\n        if(!loadImage.current){\n            ctxCanvas.current = canvas.current.getContext('2d');\n            imageTest.current.src = imgReq;\n            imageTest.current.onload = () => {\n                originWidth = imageTest.current.width;\n                originHeight = imageTest.current.height;\n                canvasHeight.current = originHeight * ( canvasWidth.current/originWidth );\n\n                canvas.current.height = canvasHeight.current;\n                canvas.current.width = canvasWidth.current;\n                scaleImage.current =  originWidth/canvasWidth.current;\n\n                let copy =  JSON.parse(JSON.stringify(data));\n\n                copy.arr.forEach(el=>{\n                    el.dots = el.dots.map((e)=> Math.round(e / scaleImage.current))\n                })\n                if(copy.arr.length > 0) setIndex(()=> 0)\n\n                setData({ arr: copy.arr});\n\n                canvasRender(data);\n                loadImage.current = true\n            }\n        } else canvasRender(data);\n    },[data]);\n\n    for (let i = 0; i < 30; i++){\n        let color = Math.floor((Math.random()*10000000)+1);\n        if(colorCanvas.indexOf(color) <= 0) colorCanvas.push((\"000000\" + color.toString(16)).slice(-6));\n    }\n\n    const canvasRender = (data) => {\n\n\n        ctxCanvas.current.clearRect(0, 0, canvasWidth.current, canvasHeight.current);\n        ctxCanvas.current.drawImage(imageTest.current, 0, 0, canvasWidth.current, canvasHeight.current);\n\n        data.arr.forEach(el=>{\n            ctxCanvas.current.beginPath();\n            for(let i = 0; i< el.dots.length; i = i + 2){\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.lineWidth =  2;\n                ctxCanvas.current.fillStyle = \"#\" + el.color;\n                ctxCanvas.current.arc(el.dots[i], el.dots[i+1], 5, 0, 2*Math.PI);\n                ctxCanvas.current.fill();\n            }\n            ctxCanvas.current.closePath();\n            if(el.type === 'line') {\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.lineWidth =  2;\n                ctxCanvas.current.moveTo(el.dots[0],el.dots[1]);\n                for(let i = 0; i< el.dots.length; i = i + 2){\n                    ctxCanvas.current.lineTo(el.dots[i],el.dots[i+1])\n                }\n                ctxCanvas.current.strokeStyle =  \"#\" + el.color;\n                ctxCanvas.current.lineWidth =  2;\n                ctxCanvas.current.stroke();\n                ctxCanvas.current.closePath();\n            }\n            if(el.type === 'area') {\n\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.lineWidth =  2;\n                ctxCanvas.current.moveTo(el.dots[0],el.dots[1]);\n                for(let i = 0; i< el.dots.length; i = i + 2){\n                    ctxCanvas.current.lineTo(el.dots[i],el.dots[i+1])\n                }\n                ctxCanvas.current.lineTo(el.dots[0],el.dots[1]);\n                let rgb = hexToRgb( \"#\" + el.color);\n                let color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', .3)';\n                ctxCanvas.current.strokeStyle = \"#\" + el.color;\n                ctxCanvas.current.fillStyle = color;\n                ctxCanvas.current.lineWidth =  2;\n                ctxCanvas.current.fill();\n                ctxCanvas.current.stroke();\n                ctxCanvas.current.closePath();\n            }\n\n        });\n    };\n\n    const checkLine = (arrTest)=> {\n        let n = (arrTest[activeIndex].dots.length + 1);\n\n        let errorElemEmpty = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'lineEmpty');\n        let errorElem = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'line');\n\n        if(n <= 3 && errorElemEmpty === -1) {\n            errorMessage.current.push({\n                type: 'lineEmpty',\n                index: activeIndex,\n                message: 'Линия ' + (activeIndex + 1) + ' должна стостоять минимум из двух точек.'\n            })\n            return\n        } else if ( n <=3 && errorElem != -1 ) {\n            errorMessage.current[errorElem].message = 'Линия ' + (activeIndex + 1) + ' должна стостоять минимум из двух точек.'\n            errorMessage.current[errorElem].type = 'lineEmpty'\n            return\n        } else if(n > 3 && errorElemEmpty != -1) errorMessage.current.splice(errorElem,1)\n\n        let intersect = false;\n        for (let i = 0; i < n - 1; i=i+2) {\n            for (let j = 0; j < n - 1; j=j+2) {\n                let test =  lineIntersect(\n                    arrTest[activeIndex].dots[i],\n                    arrTest[activeIndex].dots[i+1],\n                    arrTest[activeIndex].dots[i+2],\n                    arrTest[activeIndex].dots[i+3],\n                    arrTest[activeIndex].dots[j],\n                    arrTest[activeIndex].dots[j+1],\n                    arrTest[activeIndex].dots[j+2],\n                    arrTest[activeIndex].dots[j+3]);\n                if(test.result) intersect = true\n            }\n        }\n\n        if(intersect && errorElem == '-1') {\n            errorMessage.current.push({\n                type: 'line',\n                index: activeIndex,\n                message: 'Линия ' + (activeIndex + 1) + ' пересекает саму себя.'\n            })\n        } else if(!intersect && errorElem != '-1') errorMessage.current.splice(errorElem,1)\n    };\n\n    const checkArea = (arrTest) => {\n        let errorElem = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'area');\n        let errorElemEmpty = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'areaEmpty');\n\n        if (arrTest[activeIndex].dots.length < 5 && errorElemEmpty === -1) {\n            errorMessage.current.push({\n                type: 'areaEmpty',\n                index: activeIndex,\n                message: 'Фигура ' + (activeIndex + 1) + ' должна состоять минимум из трёх точек.'\n            });\n            return\n        } else if(arrTest[activeIndex].dots.length < 5 && errorElem != -1) {\n            errorMessage.current[errorElem].message = 'Фигура ' + (activeIndex + 1) + ' должна состоять минимум из трёх точек.'\n            errorMessage.current[errorElem].type = 'areaEmpty'\n            return\n        } else if(arrTest[activeIndex].dots.length < 5 && errorElemEmpty != -1) {\n            return\n        } else if (arrTest[activeIndex].dots.length >= 5 && errorElemEmpty != -1) errorMessage.current.splice(errorElemEmpty,1)\n\n\n        let checkConvex = convexShape(arrTest[activeIndex].dots)\n        if (!checkConvex && errorElem == '-1') {\n            errorMessage.current.push({\n                type: 'area',\n                index: activeIndex,\n                message: 'Фигура ' + (activeIndex + 1) + ' не выпуклая.'\n            });\n        } else if(checkConvex && errorElem != '-1') errorMessage.current.splice(errorElem,1)\n    };\n\n    const saveValue = (arrTest)=>{\n        setData({ arr: arrTest});\n        let copy =  JSON.parse(JSON.stringify(data));\n        copy.arr.forEach(el=>{\n            el.dots = el.dots.map((e)=> Math.round(e * scaleImage.current))\n        })\n        form.setFieldValue(props.code, copy.arr);\n    };\n\n\n    const paintCanvas = () => {\n\n        if(activeIndex !== ''){\n            let arrTest = [...data.arr];\n            if(!stateButton.eraser && !stateButton.edit){\n                arrTest[activeIndex].dots.push(mouse[0],mouse[1]);\n                if(arrTest[activeIndex].type === 'line') {\n                    checkLine(arrTest)\n                }\n                if(arrTest[activeIndex].type === 'area') {\n                    checkArea(arrTest);\n                }\n                saveValue(arrTest);\n            }\n            if(stateButton.eraser){\n                let updateArray = false;\n                for (let i = 0; i<  arrTest[activeIndex].dots.length; i=i+2){\n                    let dxArr = arrTest[activeIndex].dots[i] - mouse[0];\n                    let dyArr = arrTest[activeIndex].dots[i+1] - mouse[1];\n                    let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                    if(distArr < 10){\n                        arrTest[activeIndex].dots.splice(i,2);\n                        updateArray = true;\n                        if( arrTest[activeIndex].type === 'line') checkLine(arrTest);\n                        if( arrTest[activeIndex].type === 'area') checkArea(arrTest);\n                    }\n                }\n                if(updateArray) saveValue(arrTest);\n            }\n\n            if(move) {\n                if( arrTest[activeIndex].type === 'line') checkLine(arrTest);\n                if( arrTest[activeIndex].type === 'area') checkArea(arrTest);\n                arrTest[activeIndex].dots[indexMove] = mouse[0];\n                arrTest[activeIndex].dots[indexMove + 1] = mouse[1];\n                saveValue(arrTest);\n                move = false;\n                indexMove = null;\n            }\n        }\n    };\n    const movePoint = (e) => {\n        if(stateButton.edit && activeIndex !== ''){\n            let arrTest = [...data.arr];\n            for (let i = 0; i<  arrTest[activeIndex].dots.length; i=i+2){\n                let dxArr = arrTest[activeIndex].dots[i] - mouse[0];\n                let dyArr = arrTest[activeIndex].dots[i+1] - mouse[1];\n                let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                if(distArr < 10){\n                    move = true;\n                    indexMove = i\n                }\n            }\n        }\n    };\n\n    const mousePosition = (e) => {\n        let rect = canvas.current.getBoundingClientRect();\n        mouse = [Math.round((e.clientX - rect.left)),Math.round((e.clientY - rect.top))];\n        if(move) {\n            let arrTest = [...data.arr];\n            arrTest[activeIndex].dots[indexMove] = mouse[0];\n            arrTest[activeIndex].dots[indexMove + 1] = mouse[1];\n            canvasRender({arr: arrTest});\n        }\n    };\n\n    const deleteElement = (index,e) => {\n        e.stopPropagation();\n        let arrTest = [...data.arr];\n        let errorElem = errorMessage.current.findIndex(el => el.index === index);\n\n        errorMessage.current.forEach(el=>{\n            if(index <  el.index) {\n                let indString = el.message.indexOf(String(el.index + 1));\n                el.message = el.message.substr(0, indString) + ( el.index-- ) + el.message.substr(indString + 1);\n                el.index = el.index--;\n            }\n        });\n        if(errorElem != '-1') {\n            errorMessage.current.splice(errorElem,1);\n        }\n        setValueButton({\n            line: false,\n            area: false,\n            edit: false,\n            eraser: false,\n        });\n        setIndex(() => '');\n        cursor.current = '';\n        arrTest.splice(index,1);\n        saveValue(arrTest)\n\n    };\n\n    const panelActive = (type) => {\n        if(type === 'line'){\n            let cloneState = [...data.arr];\n            let newLine = {\n                \"color\": colorCanvas[0],\n                \"type\": \"line\",\n                \"dots\": []\n            };\n            setIndex(()=> data.arr.length);\n            cloneState.push(newLine);\n            setData({arr: [...cloneState]});\n        }\n        if(type === 'area'){\n            let cloneState = [...data.arr];\n            let newLine = {\n                \"color\": colorCanvas[0],\n                \"type\": \"area\",\n                \"dots\": []\n            };\n            setIndex(()=> data.arr.length);\n            cloneState.push(newLine);\n            setData({arr: [...cloneState]});\n        }\n        if(stateButton[type]){\n            setValueButton({\n                [type]: !stateButton[type]\n            });\n            cursor.current = data.arr[activeIndex].type === 'line' ? 'line':'area'\n            return\n        }\n        if((type === 'edit' || type === 'eraser') && (activeIndex === '' || data.arr[activeIndex].dots.length === 0)) return\n\n        cursor.current = type;\n        setValueButton({\n            [type]: !stateButton[type]\n        })\n    };\n    const changeIndex = (ind) => {\n        setIndex(() => ind);\n        setValueButton({\n            line: false,\n            area: false,\n            edit: false,\n            eraser: false,\n        });\n        cursor.current = data.arr[ind].type === 'line' ? 'line':'area'\n    };\n    const setNewColor = (e,ind) => {\n        let newColor = e.target.value.slice(1);\n        let cloneState = [...data.arr];\n        cloneState[ind].color = newColor;\n        setData({arr: [...cloneState]});\n\n        let copy =  JSON.parse(JSON.stringify(data));\n        copy.arr.forEach(el=>{\n            el.dots = el.dots.map((e)=> Math.round(e * scaleImage.current))\n        })\n        form.setFieldValue(props.code, copy.arr);\n    };\n\n\n    return (\n        <div>\n\n            <Field name={props.code} validate={(value)=>{\n                return errorMessage.current.length > 0;\n            }}>\n                {({\n                      form,\n                  }) => (\n                    <div className={\"canvasGroup\"}>\n                        <label htmlFor={props.code}>{props.name}</label>\n                        <canvas onMouseMove={(e) => mousePosition(e)}\n                                onMouseUp={(e) => paintCanvas(e,form)}\n                                onMouseDown={(e) => movePoint(e)}\n                                ref={canvas}\n                                id={props.code}\n                                className={cursor.current}\n                        >\n                        </canvas>\n                        <div className=\"canvasMenu\" style={{maxHeight:  canvasHeight.current + 'px'}}>\n                            <div className=\"panel\">\n                                <div className=\"panelItem\" onClick={ () => panelActive('line')}>\n                                    <img src={line} alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('area')} className={stateButton.area ? '':'active'}>\n                                    <img src={area} alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('edit')} className={stateButton.edit ? '':'active'}>\n                                    <img className={\"imageActive\"} src={edit} alt=\"\"/>\n                                    <img className={\"imageDefault\"} src={editActive} alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('eraser')} className={stateButton.eraser ? '':'active'}>\n                                    <img className={\"imageActive\"} src={eraser} alt=\"\"/>\n                                    <img className={\"imageDefault\"} src={eraserActive} alt=\"\"/>\n                                </div>\n                            </div>\n                            <div className=\"items\">\n                                {\n                                    data.arr.map((item,index)=>{\n                                        return <div className={\"item \" + (activeIndex === index ?'active':'')}\n                                                    key={index}\n                                                    onClick={() => changeIndex(index)}\n                                        >\n                                            {(() => {\n                                                    switch (item.type) {\n                                                        case \"line\": return <div className={\"itemLabel\"}><img src={line} alt=\"\"/>Линия {index + 1}</div>;\n                                                        case \"area\": return <div className={\"itemLabel\"}><img src={area} alt=\"\"/>Фигура {index + 1}</div>;\n                                                        default: return \"-\";\n                                                    }\n                                                }\n                                            )()}\n                                            <div className=\"color\" style={{background: '#' + item.color}}>\n                                                <input onChange={(e)=>{setNewColor(e,index,form)}} value={'#' + item.color} type=\"color\"/>\n                                            </div>\n                                            <div className=\"deleteElement\" onClick={(e) => deleteElement(index,e)}>&times;</div>\n                                        </div>\n                                    })\n                                }\n                            </div>\n                        </div>\n                        <div className=\"errorWrap\">\n                            {errorMessage.current.length > 0 && (\n                                    errorMessage.current.map((item, index) => {\n                                        return <div className=\"error\" key={index}>{item.message}</div>\n                                    })\n                            )}\n                        </div>\n                    </div>\n                )}\n            </Field>\n        </div>\n    )\n\n}\nexport default LinesAreasCanvasField\n","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/ArrowAreasCanvasField.jsx",["77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/NumberField.jsx",["93"],"import React, {Component,useRef,useEffect} from 'react';\n\nimport {Field, useFormikContext} from 'formik';\n\nfunction NumberField(props) {\n    const form = useFormikContext();\n\n    let errorInput = useRef('');\n    let maxValue = useRef(0);\n    let minValue = useRef(0);\n\n\n    useEffect(()=>{\n        errorInput.current = '';\n        maxValue.current = props.parameters.max ?? form.values[props.parameters.max_key];\n        minValue.current = props.parameters.min ?? form.values[props.parameters.minKey];\n        if(maxValue.current <= minValue.current) {\n            errorInput.current = 'Ошибка зависимых значений.'\n        } else {\n            if(maxValue.current < form.values[props.code]) {\n                form.setFieldValue(props.code, + maxValue.current);\n            }\n            if(minValue.current > form.values[props.code]) {\n                form.setFieldValue(props.code, + minValue.current);\n            }\n        }\n\n    })\n\n\n    const SetUpTest = (e,form,field) => {\n\n        if(e.target.value[0] === '0') {\n            e.target.value = e.target.value.substring(1);\n        }\n\n        if(+e.target.value < minValue.current){\n            //errorInput.current = `Минимальное значение для поля = ${min}`;\n            e.target.value = minValue.current;\n        }\n        if(+e.target.value > maxValue.current){\n            //errorInput.current  = `Максимальное значение для поля = ${max}`;\n            e.target.value = maxValue.current;\n        }\n        form.setFieldValue(field.name, +e.target.value);\n    }\n    return (\n        <Field name={props.code} validate={(value)=>{\n            return errorInput.current;\n        }}>\n            {({\n                  field,\n                  form,\n                  meta,\n              }) => (\n                <div className={\"inputGroup\"}>\n                    <label htmlFor={props.code}>{props.name}</label>\n                    <input\n                        step={1}\n                        id={props.code}\n                        min={props.parameters.min ?? form.values[props.parameters.min_key]}\n                        max={props.parameters.max ?? form.values[props.parameters.max_key]}\n                        value={field.value}\n                        type=\"number\"\n                        onChange={(e)=>SetUpTest(e,form,field)}\n                    />\n                    <div className=\"errorWrap\">\n                    {errorInput.current && (\n                        <div className=\"error\">{errorInput.current}</div>\n                    )}\n                    </div>\n                </div>\n            )}\n        </Field>\n    );\n}\n\nexport default NumberField;\n","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SelectField.jsx",["94"],"import React, {Component} from 'react';\nimport {Field} from \"formik\";\n\nfunction SelectField(props) {\n\n    return (\n        <Field name={props.code}>\n            {({\n                  field,\n                  form,\n                  meta,\n              }) => (\n                <div className={\"inputGroup\"}>\n                    <label htmlFor={props.code}>{props.name}</label>\n                    <select value={field.value.value}  id={props.code} onChange={(e) =>form.setFieldValue(field.name, + e.target.value)}>\n                        {\n                            props.parameters.options.map((item)=>{\n                                return <option value={item.value} key={item.value} >{item.name}</option>\n                            })\n                        }\n                    </select>\n\n                    {meta.error && (\n                        <div className=\"error\">{meta.error}</div>\n                    )}\n                </div>\n            )}\n        </Field>\n    )\n\n}\n\nexport default SelectField","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/RangeField.jsx",["95"],"import React, {Component,useRef,useEffect} from 'react';\n\nimport {Field, useFormikContext} from 'formik';\n\nfunction RangeField(props) {\n    const form = useFormikContext();\n    let errorInput = useRef('');\n\n    let mouseStart = useRef('');\n    let activeType = useRef('');\n    let mouseStartEvent = useRef(false);\n    let slider = useRef(null);\n    let widthSlide = useRef('');\n    let rect = useRef(null);\n    let maxValue = useRef(0);\n    let minValue = useRef(0);\n\n    useEffect(()=>{\n        errorInput.current = '';\n        rect.current = slider.current.getBoundingClientRect();\n        maxValue.current = props.parameters.max ?? form.values[props.parameters.max_key];\n        minValue.current = props.parameters.min ?? form.values[props.parameters.minKey];\n        if(maxValue.current <= minValue.current) {\n            errorInput.current = 'Ошибка зависимых значений.'\n        } else {\n            if(maxValue.current < form.values[props.code].max || form.values[props.code].max < minValue.current) {\n                form.setFieldValue(props.code + '.max', + maxValue.current);\n            }\n            if(minValue.current > form.values[props.code].min || form.values[props.code].min > maxValue.current) {\n                form.setFieldValue(props.code + '.min', + minValue.current);\n            }\n        }\n\n    });\n\n    const mouseMove = (e,click)=>{\n        if(mouseStartEvent.current || click){\n            let x = Math.round((e.clientX - rect.current.left));\n            let koof = (maxValue.current - minValue.current) / 100;\n\n            let result = (Math.round((x/widthSlide.current * 100) * koof / props.parameters.step)) * props.parameters.step + minValue.current;\n\n            if( activeType.current === '.min' && result >= minValue.current && result < form.values[props.code].max){\n                form.setFieldValue(props.code + activeType.current, +result);\n            }\n            if( activeType.current === '.max' && result > form.values[props.code].min && result <= maxValue.current){\n                form.setFieldValue(props.code + activeType.current, +result);\n            }\n        }\n    }\n    const changeSelect = (e)=>{\n\n        let x = Math.round((e.clientX - rect.current.left));\n        widthSlide.current = rect.current.width;\n        let koof = (maxValue.current - minValue.current) / 100;\n        let result = (Math.round((x/widthSlide.current * 100) * koof / props.parameters.step)) * props.parameters.step + minValue.current;\n\n\n        let p = Math.abs(result - form.values[props.code].min);\n        let p2 =Math.abs( form.values[props.code].max - result);\n\n        if (p < p2) activeType.current = '.min';\n        else if (p > p2) activeType.current = '.max';\n        else activeType.current = '.min';\n\n        mouseMove(e,true)\n\n        //mouseMove(e, true)\n    };\n    const mouseDown = (e,type,field)=>{\n        activeType.current = type;\n        widthSlide.current = rect.current.width;\n        mouseStart.current = Math.round((e.clientX - rect.current.left));\n        mouseStartEvent.current = true;\n        window.addEventListener('mouseup', mouseUp);\n        window.addEventListener('mousemove', mouseMove);\n    }\n    const mouseUp = (e)=>{\n        mouseStartEvent.current = false;\n        window.removeEventListener('mouseup', mouseUp);\n        window.removeEventListener('mousemove', mouseMove);\n    }\n\n    return (\n        <Field name={props.code} validate={(value)=>{\n            return errorInput.current;\n        }}>\n            {({\n                  field,\n                  form,\n                  meta,\n              }) => (\n                <div className={`inputGroup  ${errorInput.current === '' ? '':'disabledValue'}`} >\n                    <label htmlFor={props.code}>{props.name}</label>\n                    <div className=\"fakeSliderWrap\">\n                        <div className={\"fakeSlider fakeSliderMultiple\"} ref={slider}  onClick={(e)=> changeSelect(e)}>\n                            <div className={\"selectNew selectNewMin\"} style={{\n                                width: ((form.values[props.code].min - props.parameters.min ?? form.values[props.parameters.minKey])/((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 + '%')}}>\n                            </div>\n                            <div className={`selectActive  ${activeType.current === '.min'? 'selectActiveMin':'selectActiveMax'}`}  style={{\n                                width: (100 - ((form.values[props.code].min - props.parameters.min ?? form.values[props.parameters.minKey])/((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 ) - (100 - ((form.values[props.code].max  - props.parameters.min ?? form.values[props.parameters.minKey])/((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100)) + '%')}}>\n                            </div>\n                            <div className={\"selectNew selectNewMax\"} style={{\n                                width: (100 - ((form.values[props.code].max  - props.parameters.min ?? form.values[props.parameters.minKey])/((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100) + '%')}}>\n                            </div>\n                            <div className=\"thumb\" style={{\n                                left: ((form.values[props.code].min - props.parameters.min ?? form.values[props.parameters.minKey]) / ((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 + '%')\n                            }}\n                                 onMouseDown={(e) => mouseDown(e,'.min',field)}\n                            >\n                            </div>\n                            <div className=\"thumb\" style={{\n                                left: ((form.values[props.code].max - props.parameters.min ?? form.values[props.parameters.minKey]) / ((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 + '%')\n                            }}\n                                 onMouseDown={(e) => mouseDown(e,'.max', )}\n                            >\n                            </div>\n                        </div>\n                    </div>\n\n                    <div className=\"labelValueWrap\">\n                        <div className={\"labelValue\"}>\n                            <div className=\"min\">{props.parameters.min ?? form.values[props.parameters.min_key]}</div>\n                            <div className=\"value\"\n                                 style={{left:((form.values[props.code].min - props.parameters.min ?? form.values[props.parameters.minKey]) / ((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 + '%')\n                            }}>{field.value.min}</div>\n                            <div className=\"value\"\n                                 style={{left: ((form.values[props.code].max - props.parameters.min ?? form.values[props.parameters.minKey]) / ((props.parameters.max ?? form.values[props.parameters.max_key]) - (props.parameters.min ?? form.values[props.parameters.minKey])) * 100 + '%')\n                                 }}>{field.value.max}</div>\n                            <div className=\"max\">{props.parameters.max ?? form.values[props.parameters.max_key]}</div>\n                        </div>\n                    </div>\n                    {errorInput.current !== '' && (\n                        <div className=\"error\">{errorInput.current}</div>\n                    )}\n\n                </div>\n            )}\n        </Field>\n    )\n\n}\nexport default RangeField\n","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/utils.js",[],{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","replacedBy":"99"},{"ruleId":"100","severity":1,"message":"101","line":1,"column":16,"nodeType":"102","messageId":"103","endLine":1,"endColumn":25},{"ruleId":"100","severity":1,"message":"101","line":2,"column":16,"nodeType":"102","messageId":"103","endLine":2,"endColumn":25},{"ruleId":"100","severity":1,"message":"104","line":6,"column":8,"nodeType":"102","messageId":"103","endLine":6,"endColumn":18},{"ruleId":"100","severity":1,"message":"105","line":8,"column":8,"nodeType":"102","messageId":"103","endLine":8,"endColumn":18},{"ruleId":"100","severity":1,"message":"106","line":16,"column":21,"nodeType":"102","messageId":"103","endLine":16,"endColumn":31},{"ruleId":"107","severity":1,"message":"108","line":58,"column":31,"nodeType":"109","endLine":58,"endColumn":54},{"ruleId":"107","severity":1,"message":"110","line":59,"column":32,"nodeType":"109","endLine":59,"endColumn":56},{"ruleId":"111","severity":1,"message":"112","line":149,"column":40,"nodeType":"113","messageId":"114","endLine":149,"endColumn":42},{"ruleId":"111","severity":1,"message":"112","line":153,"column":43,"nodeType":"113","messageId":"114","endLine":153,"endColumn":45},{"ruleId":"111","severity":1,"message":"115","line":171,"column":35,"nodeType":"113","messageId":"114","endLine":171,"endColumn":37},{"ruleId":"111","severity":1,"message":"112","line":177,"column":43,"nodeType":"113","messageId":"114","endLine":177,"endColumn":45},{"ruleId":"111","severity":1,"message":"112","line":191,"column":69,"nodeType":"113","messageId":"114","endLine":191,"endColumn":71},{"ruleId":"111","severity":1,"message":"112","line":195,"column":74,"nodeType":"113","messageId":"114","endLine":195,"endColumn":76},{"ruleId":"111","severity":1,"message":"112","line":197,"column":76,"nodeType":"113","messageId":"114","endLine":197,"endColumn":78},{"ruleId":"111","severity":1,"message":"115","line":201,"column":39,"nodeType":"113","messageId":"114","endLine":201,"endColumn":41},{"ruleId":"111","severity":1,"message":"112","line":207,"column":44,"nodeType":"113","messageId":"114","endLine":207,"endColumn":46},{"ruleId":"111","severity":1,"message":"112","line":299,"column":22,"nodeType":"113","messageId":"114","endLine":299,"endColumn":24},{"ruleId":"116","severity":1,"message":"117","line":400,"column":97,"nodeType":"118","endLine":400,"endColumn":139},{"ruleId":"116","severity":1,"message":"117","line":403,"column":97,"nodeType":"118","endLine":403,"endColumn":139},{"ruleId":"116","severity":1,"message":"117","line":407,"column":99,"nodeType":"118","endLine":407,"endColumn":143},{"ruleId":"100","severity":1,"message":"101","line":1,"column":16,"nodeType":"102","messageId":"103","endLine":1,"endColumn":25},{"ruleId":"100","severity":1,"message":"106","line":18,"column":21,"nodeType":"102","messageId":"103","endLine":18,"endColumn":31},{"ruleId":"107","severity":1,"message":"108","line":62,"column":31,"nodeType":"109","endLine":62,"endColumn":54},{"ruleId":"107","severity":1,"message":"110","line":63,"column":32,"nodeType":"109","endLine":63,"endColumn":56},{"ruleId":"111","severity":1,"message":"112","line":168,"column":62,"nodeType":"113","messageId":"114","endLine":168,"endColumn":64},{"ruleId":"111","severity":1,"message":"112","line":173,"column":67,"nodeType":"113","messageId":"114","endLine":173,"endColumn":69},{"ruleId":"111","severity":1,"message":"112","line":176,"column":69,"nodeType":"113","messageId":"114","endLine":176,"endColumn":71},{"ruleId":"111","severity":1,"message":"115","line":180,"column":39,"nodeType":"113","messageId":"114","endLine":180,"endColumn":41},{"ruleId":"111","severity":1,"message":"112","line":187,"column":44,"nodeType":"113","messageId":"114","endLine":187,"endColumn":46},{"ruleId":"111","severity":1,"message":"115","line":211,"column":38,"nodeType":"113","messageId":"114","endLine":211,"endColumn":40},{"ruleId":"111","severity":1,"message":"112","line":218,"column":43,"nodeType":"113","messageId":"114","endLine":218,"endColumn":45},{"ruleId":"100","severity":1,"message":"119","line":342,"column":13,"nodeType":"102","messageId":"103","endLine":342,"endColumn":22},{"ruleId":"116","severity":1,"message":"117","line":469,"column":102,"nodeType":"118","endLine":469,"endColumn":144},{"ruleId":"116","severity":1,"message":"117","line":472,"column":97,"nodeType":"118","endLine":472,"endColumn":139},{"ruleId":"116","severity":1,"message":"117","line":476,"column":98,"nodeType":"118","endLine":476,"endColumn":141},{"ruleId":"116","severity":1,"message":"117","line":480,"column":99,"nodeType":"118","endLine":480,"endColumn":143},{"ruleId":"100","severity":1,"message":"101","line":1,"column":16,"nodeType":"102","messageId":"103","endLine":1,"endColumn":25},{"ruleId":"100","severity":1,"message":"101","line":1,"column":16,"nodeType":"102","messageId":"103","endLine":1,"endColumn":25},{"ruleId":"100","severity":1,"message":"101","line":1,"column":16,"nodeType":"102","messageId":"103","endLine":1,"endColumn":25},"no-native-reassign",["120"],"no-negated-in-lhs",["121"],"no-unused-vars","'Component' is defined but never used.","Identifier","unusedVar","'areaActive' is defined but never used.","'lineActive' is defined but never used.","'submitForm' is assigned a value but never used.","react-hooks/exhaustive-deps","Assignments to the 'originWidth' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","MemberExpression","Assignments to the 'originHeight' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","'errorElem' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]