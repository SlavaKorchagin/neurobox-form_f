[{"/Users/slava/Desktop/work/neurobox-form_f/src/index.js":"1","/Users/slava/Desktop/work/neurobox-form_f/src/App.js":"2","/Users/slava/Desktop/work/neurobox-form_f/src/reportWebVitals.js":"3","/Users/slava/Desktop/work/neurobox-form_f/src/form/index.jsx":"4","/Users/slava/Desktop/work/neurobox-form_f/src/functions.js":"5","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SliderField.jsx":"6","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/LinesAreasCanvasField.jsx":"7","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/ArrowAreasCanvasField.jsx":"8","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/NumberField.jsx":"9","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SelectField.jsx":"10","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/RangeField.jsx":"11","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/utils.js":"12"},{"size":478,"mtime":1612473930326,"results":"13","hashOfConfig":"14"},{"size":537,"mtime":1612473930320,"results":"15","hashOfConfig":"14"},{"size":362,"mtime":1612473930326,"results":"16","hashOfConfig":"14"},{"size":2145,"mtime":1612481491938,"results":"17","hashOfConfig":"14"},{"size":976,"mtime":1612473930326,"results":"18","hashOfConfig":"14"},{"size":5292,"mtime":1612477565119,"results":"19","hashOfConfig":"14"},{"size":16107,"mtime":1612483815354,"results":"20","hashOfConfig":"14"},{"size":20251,"mtime":1612483802770,"results":"21","hashOfConfig":"14"},{"size":2703,"mtime":1612478815473,"results":"22","hashOfConfig":"14"},{"size":1017,"mtime":1612473930323,"results":"23","hashOfConfig":"14"},{"size":7967,"mtime":1612477814002,"results":"24","hashOfConfig":"14"},{"size":2972,"mtime":1612483441833,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"11cktcs",{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"46","messages":"47","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"43"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"43"},"/Users/slava/Desktop/work/neurobox-form_f/src/index.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/App.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/reportWebVitals.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/form/index.jsx",[],"/Users/slava/Desktop/work/neurobox-form_f/src/functions.js",[],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SliderField.jsx",["53"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/LinesAreasCanvasField.jsx",["54","55","56","57","58","59","60","61","62","63","64","65"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/ArrowAreasCanvasField.jsx",["66","67","68","69","70","71","72","73","74","75","76","77","78"],"import React, {Component, useEffect, useState,useRef} from 'react';\nimport {Field, useFormikContext} from \"formik\";\nimport {convexShape,hexToRgb,inPoly} from './utils'\n\nfunction ArrowAreasCanvasField(props) {\n\n    const form = useFormikContext();\n\n    let imgReq = 'https://mtdi.mosreg.ru/upload/files/g/i/gio9SFV0y7O9ZsNltS5E62m8vYlN7Y2OBMUSoP6F7lej2dgikbj1X14lv0yV8ymCPdCV6egCP1UzkAjCtWHkzrZQyrDybUU6.jpg'\n    const { values, submitForm } = useFormikContext();\n\n\n\n    let ctxCanvas = useRef(null);\n    let errorMessage = useRef([]);\n    let imageTest = useRef(new Image());\n    const canvasWidth = useRef(600);\n    const canvasHeight = useRef('');\n    let loadImage = useRef(false);\n    let originWidth = 0;\n    let originHeight = 0;\n    let mouse = [];\n    let colorCanvas = [];\n\n    let move = false;\n    let indexMove = null;\n    let moveArrow = false;\n    let indexMoveArrow = null;\n    let scaleImage = useRef('');\n\n    const canvas = useRef(null);\n\n    const [data, setData] = useState({\n        arr: values.areas_with_directions && values.areas_with_directions.length > 0 ? values.areas_with_directions : []\n    });\n\n\n    const [activeIndex, setIndex] = useState('');\n\n    const [stateButton,setValueButton] = useState({\n        areaSpeed: false,\n        area: false,\n        edit: false,\n        eraser: false,\n        arrow: false\n    });\n\n    useEffect(()=>{\n        if(!loadImage.current){\n            ctxCanvas.current = canvas.current.getContext('2d');\n            imageTest.current.src = imgReq;\n            imageTest.current.onload = () => {\n                originWidth = imageTest.current.width;\n                originHeight = imageTest.current.height;\n                canvasHeight.current = originHeight * ( canvasWidth.current/originWidth );\n\n                canvas.current.height = canvasHeight.current;\n                canvas.current.width = canvasWidth.current;\n                scaleImage.current = originWidth/canvasWidth.current;\n\n                let dataScale =  [...data.arr];\n                dataScale.forEach(el=>{\n                    el.dots = el.dots.map((e)=> Math.round(e / scaleImage.current))\n                    el.arrow = el.arrow.map((e)=> Math.round(e / scaleImage.current))\n                })\n                setData({ arr: dataScale});\n\n                canvasRender(data);\n                loadImage.current = true\n            }\n        } else canvasRender(data);\n\n    },[data]);\n\n    for (let i = 0; i < 30; i++){\n        let color = Math.floor((Math.random()*10000000)+1);\n        if(colorCanvas.indexOf(color) <= 0) colorCanvas.push((\"000000\" + color.toString(16)).slice(-6));\n    }\n\n    const canvasRender = (data) => {\n\n        ctxCanvas.current.clearRect(0, 0, canvasWidth.current, canvasHeight.current);\n        ctxCanvas.current.drawImage(imageTest.current, 0, 0, canvasWidth.current, canvasHeight.current);\n\n        data.arr.forEach(el=>{\n            ctxCanvas.current.beginPath();\n            for(let i = 0; i< el.dots.length; i = i + 2){\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.fillStyle = \"#\" + el.color;\n                ctxCanvas.current.arc(el.dots[i], el.dots[i+1], 5, 0, 2*Math.PI);\n                ctxCanvas.current.fill();\n            }\n            ctxCanvas.current.closePath();\n\n            if(el.type === 'speed_arrow_area' || el.type ===  'arrow_area' ) {\n\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.moveTo(el.dots[0],el.dots[1]);\n                for(let i = 0; i< el.dots.length; i = i + 2){\n                    ctxCanvas.current.lineTo(el.dots[i],el.dots[i+1])\n                }\n                ctxCanvas.current.lineTo(el.dots[0],el.dots[1]);\n                let rgb = hexToRgb( \"#\" + el.color);\n                let color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', .5)';\n                ctxCanvas.current.fillStyle = color ;\n                ctxCanvas.current.strokeStyle = \"#\" + el.color ;\n                ctxCanvas.current.lineWidth =  3;\n                ctxCanvas.current.fill();\n                ctxCanvas.current.stroke();\n                ctxCanvas.current.closePath();\n\n                ctxCanvas.current.beginPath();\n                ctxCanvas.current.fillStyle = el.color ;\n                for(let i = 0; i< el.arrow.length; i = i + 2){\n                    ctxCanvas.current.arc(el.arrow[i], el.arrow[i+1], 4, 0, 2*Math.PI);\n                }\n                ctxCanvas.current.fill();\n                ctxCanvas.current.closePath();\n                if(el.arrow.length === 4) canvasArrow(el.arrow[0],el.arrow[1],el.arrow[2],el.arrow[3])\n            }\n\n        });\n    };\n    const canvasArrow = (fromx, fromy, tox, toy) =>{\n        let arrowLen = 25;\n        let dx = tox-fromx;\n        let dy = toy-fromy;\n        let angle = Math.atan2(dy,dx);\n        ctxCanvas.current.beginPath();\n        ctxCanvas.current.lineWidth =  5;\n        ctxCanvas.current.moveTo(fromx, fromy);\n        ctxCanvas.current.lineTo(tox, toy);\n        ctxCanvas.current.stroke();\n        ctxCanvas.current.moveTo(tox, toy);\n        ctxCanvas.current.lineTo(tox-arrowLen*Math.cos(angle-Math.PI/6),toy-arrowLen*Math.sin(angle-Math.PI/6));\n        ctxCanvas.current.stroke();\n        ctxCanvas.current.moveTo(tox, toy);\n        ctxCanvas.current.lineTo(tox-arrowLen*Math.cos(angle+Math.PI/6),toy-arrowLen*Math.sin(angle+Math.PI/6));\n        ctxCanvas.current.stroke();\n        ctxCanvas.current.closePath();\n    };\n\n    const checkArea = (arrTest) => {\n        let errorElem = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'area');\n        let checkConvex = convexShape(arrTest[activeIndex].dots)\n        if (!checkConvex && errorElem == '-1') {\n            errorMessage.current.push({\n                type: 'area',\n                index: activeIndex,\n                message: 'Фигура ' + (activeIndex + 1) + ' не выпуклая.'\n            });\n        } else if(checkConvex && errorElem != '-1') errorMessage.current.splice(errorElem,1)\n    };\n    const arrowInPoly = (arrTest)=>{\n\n        let testInPoly = true;\n        if(arrTest[activeIndex].arrow.length === 4) {\n            testInPoly = inPoly(arrTest[activeIndex].arrow[0],arrTest[activeIndex].arrow[1], arrTest[activeIndex].dots) && inPoly(arrTest[activeIndex].arrow[2],arrTest[activeIndex].arrow[3], arrTest[activeIndex].dots);\n            let errorCount = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'arrow' && el.arrowCount);\n            errorMessage.current.splice(errorCount,1)\n        }\n\n        let errorElem = errorMessage.current.findIndex(el => el.index === activeIndex && el.type === 'arrow');\n        if(arrTest[activeIndex].arrow.length === 2){\n            errorMessage.current.push({\n                type: 'arrow',\n                index: activeIndex,\n                arrowCount: true,\n                message: 'Направление не может содержать только одну точку (область ' + (activeIndex + 1) + ')'\n            });\n        }\n        if (!testInPoly && errorElem == '-1') {\n            errorMessage.current.push({\n                type: 'arrow',\n                index: activeIndex,\n                message: 'Направление должно находиться внутри активной области (область ' + (activeIndex + 1) + ')'\n            });\n        } else if(testInPoly && errorElem != '-1') errorMessage.current.splice(errorElem,1)\n\n    };\n    const saveValue = (arrTest)=>{\n        setData({ arr: arrTest});\n        let copy =  JSON.parse(JSON.stringify(data));\n        copy.arr.forEach(el=>{\n            el.dots = el.dots.map((e)=> Math.round(e * scaleImage.current))\n            el.arrow = el.arrow.map((e)=> Math.round(e * scaleImage.current))\n        })\n        form.setFieldValue(props.code, copy.arr);\n    };\n\n\n    const paintCanvas = (e,form) => {\n\n        if(activeIndex !== ''){\n            let arrTest = [...data.arr];\n            if(!stateButton.eraser && !stateButton.edit && !stateButton.arrow){\n                arrTest[activeIndex].dots.push(mouse[0],mouse[1]);\n                if(arrTest[activeIndex].dots.length > 5) {\n                    checkArea(arrTest)\n                }\n                saveValue(arrTest)\n            }\n            if(stateButton.eraser){\n                let updateArray = false;\n                for (let i = 0; i<  arrTest[activeIndex].dots.length; i=i+2){\n                    let dxArr = arrTest[activeIndex].dots[i] - mouse[0];\n                    let dyArr = arrTest[activeIndex].dots[i+1] - mouse[1];\n                    let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                    if(distArr < 10){\n                        arrTest[activeIndex].dots.splice(i,2);\n                        updateArray = true;\n                        checkArea(arrTest);\n                    }\n                }\n                for (let i = 0; i<  arrTest[activeIndex].arrow.length; i=i+2){\n                    let dxArr = arrTest[activeIndex].arrow[i] - mouse[0];\n                    let dyArr = arrTest[activeIndex].arrow[i+1] - mouse[1];\n                    let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                    if(distArr < 10){\n                        arrTest[activeIndex].arrow.splice(i,2);\n                        updateArray = true;\n                        arrowInPoly(arrTest)\n                    }\n                }\n                if(updateArray) saveValue(arrTest)\n            }\n            if(move) {\n                arrTest[activeIndex].dots[indexMove] = mouse[0];\n                arrTest[activeIndex].dots[indexMove + 1] = mouse[1];\n                checkArea(arrTest);\n                saveValue(arrTest);\n                move = false;\n                indexMove = null;\n            }\n            if(moveArrow) {\n                arrTest[activeIndex].arrow[indexMoveArrow] = mouse[0];\n                arrTest[activeIndex].arrow[indexMoveArrow + 1] = mouse[1];\n                arrowInPoly(arrTest);\n                saveValue(arrTest);\n\n                moveArrow = false;\n                indexMoveArrow = null;\n            }\n            if(stateButton.arrow) {\n                if(arrTest[activeIndex].arrow.length === 4) {\n                    alert('Область может содержать только одно направление, для изменения перейдите в соответствуюшие пункты');\n                    return\n                }\n                arrTest[activeIndex].arrow.push(mouse[0]);\n                arrTest[activeIndex].arrow.push(mouse[1]);\n                arrowInPoly(arrTest);\n                saveValue(arrTest);\n            }\n        }\n        canvasRender(data);\n    };\n\n\n\n    const movePoint = (e) => {\n        if(stateButton.edit){\n            let arrTest = [...data.arr];\n            for (let i = 0; i<  arrTest[activeIndex].dots.length; i=i+2){\n                let dxArr = arrTest[activeIndex].dots[i] - mouse[0];\n                let dyArr = arrTest[activeIndex].dots[i+1] - mouse[1];\n                let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                if(distArr < 10){\n                    move = true;\n                    indexMove = i\n                }\n            }\n            for (let i = 0; i<  arrTest[activeIndex].arrow.length; i=i+2){\n                let dxArr = arrTest[activeIndex].arrow[i] - mouse[0];\n                let dyArr = arrTest[activeIndex].arrow[i+1] - mouse[1];\n                let distArr = Math.sqrt(dxArr * dxArr + dyArr * dyArr);\n                if(distArr < 10){\n                    moveArrow = true;\n                    indexMoveArrow = i\n                }\n            }\n        }\n    };\n\n    const mousePosition = (e) => {\n        let rect = canvas.current.getBoundingClientRect();\n        mouse = [Math.round((e.clientX - rect.left)),Math.round((e.clientY - rect.top))];\n        if(move) {\n            let arrTest = [...data.arr];\n            arrTest[activeIndex].dots[indexMove] = mouse[0];\n            arrTest[activeIndex].dots[indexMove + 1] = mouse[1];\n            canvasRender({arr: arrTest});\n        }\n        if(moveArrow) {\n            let arrTest = [...data.arr];\n            arrTest[activeIndex].arrow[indexMoveArrow] = mouse[0];\n            arrTest[activeIndex].arrow[indexMoveArrow + 1] = mouse[1];\n            canvasRender({arr: arrTest});\n        }\n    };\n    const indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el.index === val ? [...acc, i] : acc), []);\n\n    const deleteElement = (index) => {\n        let arrTest = [...data.arr];\n        let errorElem = errorMessage.current.findIndex(el => el.index === index);\n        let errorElem2 = indexOfAll(errorMessage.current, index);\n\n        errorMessage.current.forEach(el=>{\n            if(index <  el.index) {\n                let indString = el.message.indexOf(String(el.index + 1));\n                el.message = el.message.substr(0, indString) + ( el.index-- ) + el.message.substr(indString + 1);\n                el.index = el.index--;\n            }\n        });\n        if(errorElem2.length > 0) {\n            errorElem2.reverse().forEach(el=>{\n                errorMessage.current.splice(el,1);\n            });\n\n        }\n        arrTest.splice(index,1);\n        saveValue(arrTest)\n    };\n\n    const panelActive = (type) => {\n        if(type === 'area'){\n            let cloneState = [...data.arr];\n            let newLine = {\n                \"color\": colorCanvas[0],\n                \"type\": \"arrow_area\",\n                \"dots\": [],\n                \"arrow\": []\n            };\n            setIndex(()=> data.arr.length);\n            cloneState.push(newLine);\n            setData({arr: [...cloneState]});\n        }\n        if(type === 'areaSpeed'){\n            let cloneState = [...data.arr];\n            let newLine = {\n                \"color\": colorCanvas[0],\n                \"type\": \"speed_arrow_area\",\n                \"dots\": [],\n                \"arrow\": []\n            };\n            setIndex(()=> data.arr.length);\n            cloneState.push(newLine);\n            setData({arr: [...cloneState]});\n        }\n        if(type === 'edit' || type === 'eraser' ) {\n            if(activeIndex === '') {\n                alert('Для начала нужно выбрать создать или выбрать элемент');\n                return\n            }\n            if(data.arr[activeIndex].dots.length === 0) {\n                alert('У данного элемента нет точек');\n                return\n            }\n        }\n        setValueButton({\n            [type]: !stateButton[type]\n        })\n    };\n    const changeIndex = (ind) => {\n        setValueButton({\n            areaSpeed: false,\n            area: false,\n            edit: false,\n            eraser: false,\n            arrow: false\n        });\n        setIndex(() => ind)\n    };\n    const setNewColor = (e,ind) => {\n        let newColor = e.target.value.slice(1);\n        let cloneState = [...data.arr];\n        cloneState[ind].color = newColor;\n        setData({arr: [...cloneState]});\n        let copy =  JSON.parse(JSON.stringify(data));\n        copy.arr.forEach(el=>{\n            el.dots = el.dots.map((e)=> Math.round(e * scaleImage.current))\n            el.arrow = el.arrow.map((e)=> Math.round(e * scaleImage.current))\n        })\n        form.setFieldValue(props.code, copy.arr);\n    };\n\n\n    return (\n        <div>\n            <Field name={props.code} validate={(value)=>{\n                return errorMessage.current.length > 0;\n            }}>\n                {({\n                      field,\n                      form,\n                      meta,\n                  }) => (\n                    <div className={\"canvasGroup\"}>\n                        <label htmlFor={props.code}>{props.name}</label>\n                        <canvas onMouseMove={(e) => mousePosition(e)}\n                                onMouseUp={(e) => paintCanvas(e,form)}\n                                onMouseDown={(e) => movePoint(e)}\n                                ref={canvas}\n                                id={props.code}>\n                        </canvas>\n                        <div className=\"canvasMenu\" style={{maxHeight:  canvasHeight.current + 'px'}}>\n                            <div className=\"panel\">\n                                <div className=\"panelItem\" onClick={ () => panelActive('area')}>\n                                    <img src=\"svg/area.svg\" alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('areaSpeed')} className={stateButton.area ? '':'active'}>\n                                    <img src=\"svg/areaSpeed.svg\" alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('edit')} className={stateButton.edit ? '':'active'}>\n                                    <img className={\"imageActive\"} src=\"svg/edit.svg\" alt=\"\"/>\n                                    <img className={\"imageDefault\"} src=\"svg/editActive.svg\" alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('arrow')} className={stateButton.arrow ? '':'active'}>\n                                    <img className={\"imageActive\"} src=\"svg/arrow.svg\" alt=\"\"/>\n                                    <img className={\"imageDefault\"} src=\"svg/arrowActive.svg\" alt=\"\"/>\n                                </div>\n                                <div className=\"panelItem\" onClick={ () => panelActive('eraser')} className={stateButton.eraser ? '':'active'}>\n                                    <img className={\"imageActive\"} src=\"svg/eraser.svg\" alt=\"\"/>\n                                    <img className={\"imageDefault\"} src=\"svg/eraserActive.svg\" alt=\"\"/>\n                                </div>\n                            </div>\n                            <div className=\"items\">\n                                {\n                                    data.arr.map((item,index)=>{\n                                        return <div className={\"item \" + (activeIndex === index ?'active':'')}\n                                                    key={index}\n                                                    onClick={() => changeIndex(index)}\n                                        >\n                                            {(() => {\n                                                    switch (item.type) {\n                                                        case \"arrow_area\": return <div className={\"itemLabel\"}><img src=\"svg/area.svg\" alt=\"\"/>Область {index + 1}</div>;\n                                                        case \"speed_arrow_area\": return <div className={\"itemLabel\"}><img src=\"svg/areaSpeed.svg\" alt=\"\"/>Область {index + 1}</div>;\n                                                        default: return \"-\";\n                                                    }\n                                                }\n                                            )()}\n                                            <div className=\"color\" style={{background: '#' + item.color}}>\n                                                <input onChange={(e)=>{setNewColor(e,index,form)}} value={'#' + item.color} type=\"color\"/>\n                                            </div>\n                                            <div className=\"deleteElement\" onClick={() => deleteElement(index,form)}>&times;</div>\n                                        </div>\n                                    })\n                                }\n                            </div>\n                        </div>\n                        <div className=\"errorWrap\">\n                            {errorMessage.current.length > 0 && (\n                                errorMessage.current.map((item, index) => {\n                                    return <div className=\"error\" key={index}>{item.message}</div>\n                                })\n                            )}\n                        </div>\n                    </div>\n                )}\n            </Field>\n        </div>\n    )\n\n}\n\nexport default ArrowAreasCanvasField\n",["79","80"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/NumberField.jsx",["81"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/SelectField.jsx",["82"],"import React, {Component} from 'react';\nimport {Field} from \"formik\";\n\nfunction SelectField(props) {\n\n    return (\n        <Field name={props.code}>\n            {({\n                  field,\n                  form,\n                  meta,\n              }) => (\n                <div className={\"inputGroup\"}>\n                    <label htmlFor={props.code}>{props.name}</label>\n                    <select value={field.value.value}  id={props.code} onChange={(e) =>form.setFieldValue(field.name, + e.target.value)}>\n                        {\n                            props.parameters.options.map((item)=>{\n                                return <option value={item.value} key={item.value} >{item.name}</option>\n                            })\n                        }\n                    </select>\n\n                    {meta.error && (\n                        <div className=\"error\">{meta.error}</div>\n                    )}\n                </div>\n            )}\n        </Field>\n    )\n\n}\n\nexport default SelectField","/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/RangeField.jsx",["83"],"/Users/slava/Desktop/work/neurobox-form_f/src/form/fields/utils.js",[],{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":2,"column":16,"nodeType":"86","messageId":"87","endLine":2,"endColumn":25},{"ruleId":"84","severity":1,"message":"88","line":8,"column":21,"nodeType":"86","messageId":"87","endLine":8,"endColumn":31},{"ruleId":"89","severity":1,"message":"90","line":49,"column":31,"nodeType":"91","endLine":49,"endColumn":54},{"ruleId":"89","severity":1,"message":"92","line":50,"column":32,"nodeType":"91","endLine":50,"endColumn":56},{"ruleId":"93","severity":1,"message":"94","line":138,"column":35,"nodeType":"95","messageId":"96","endLine":138,"endColumn":37},{"ruleId":"93","severity":1,"message":"97","line":144,"column":43,"nodeType":"95","messageId":"96","endLine":144,"endColumn":45},{"ruleId":"93","severity":1,"message":"94","line":150,"column":39,"nodeType":"95","messageId":"96","endLine":150,"endColumn":41},{"ruleId":"93","severity":1,"message":"97","line":156,"column":44,"nodeType":"95","messageId":"96","endLine":156,"endColumn":46},{"ruleId":"93","severity":1,"message":"97","line":247,"column":22,"nodeType":"95","messageId":"96","endLine":247,"endColumn":24},{"ruleId":"98","severity":1,"message":"99","line":333,"column":97,"nodeType":"100","endLine":333,"endColumn":139},{"ruleId":"98","severity":1,"message":"99","line":336,"column":97,"nodeType":"100","endLine":336,"endColumn":139},{"ruleId":"98","severity":1,"message":"99","line":340,"column":99,"nodeType":"100","endLine":340,"endColumn":143},{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"88","line":10,"column":21,"nodeType":"86","messageId":"87","endLine":10,"endColumn":31},{"ruleId":"89","severity":1,"message":"90","line":53,"column":31,"nodeType":"91","endLine":53,"endColumn":54},{"ruleId":"89","severity":1,"message":"92","line":54,"column":32,"nodeType":"91","endLine":54,"endColumn":56},{"ruleId":"93","severity":1,"message":"94","line":147,"column":39,"nodeType":"95","messageId":"96","endLine":147,"endColumn":41},{"ruleId":"93","severity":1,"message":"97","line":153,"column":44,"nodeType":"95","messageId":"96","endLine":153,"endColumn":46},{"ruleId":"93","severity":1,"message":"94","line":173,"column":38,"nodeType":"95","messageId":"96","endLine":173,"endColumn":40},{"ruleId":"93","severity":1,"message":"97","line":179,"column":43,"nodeType":"95","messageId":"96","endLine":179,"endColumn":45},{"ruleId":"84","severity":1,"message":"101","line":305,"column":13,"nodeType":"86","messageId":"87","endLine":305,"endColumn":22},{"ruleId":"98","severity":1,"message":"99","line":411,"column":102,"nodeType":"100","endLine":411,"endColumn":144},{"ruleId":"98","severity":1,"message":"99","line":414,"column":97,"nodeType":"100","endLine":414,"endColumn":139},{"ruleId":"98","severity":1,"message":"99","line":418,"column":98,"nodeType":"100","endLine":418,"endColumn":141},{"ruleId":"98","severity":1,"message":"99","line":422,"column":99,"nodeType":"100","endLine":422,"endColumn":143},{"ruleId":"102","replacedBy":"103"},{"ruleId":"104","replacedBy":"105"},{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":1,"column":16,"nodeType":"86","messageId":"87","endLine":1,"endColumn":25},"no-unused-vars","'Component' is defined but never used.","Identifier","unusedVar","'submitForm' is assigned a value but never used.","react-hooks/exhaustive-deps","Assignments to the 'originWidth' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","MemberExpression","Assignments to the 'originHeight' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","'errorElem' is assigned a value but never used.","no-native-reassign",["106"],"no-negated-in-lhs",["107"],"no-global-assign","no-unsafe-negation"]